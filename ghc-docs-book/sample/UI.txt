{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE CPP #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MagicHash #-}
{-# LANGUAGE MultiWayIf #-}
{-# LANGUAGE NondecreasingIndentation #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE ViewPatterns #-}
{-# OPTIONS -fno-cse #-}
-- -fno-cse is needed for GLOBAL_VAR's to behave properly
-----------------------------------------------------------------------------
--
-- GHC Interactive User Interface
--
-- (c) The GHC Team 2005-2006
--
-----------------------------------------------------------------------------
-- #include "HsVersions.h"
-- GHCi
-- The GHC interface
-- Other random utilities
-- Haskell Libraries
-----------------------------------------------------------------------------
-- Hugs users are accustomed to :e, so make sure it doesn't overlap
-- hidden commands
-- We initialize readline (in the interactiveUI function) to use
-- word_break_chars as the default set of completion word break characters.
-- This can be overridden for a particular command (for example, filename
-- expansion shouldn't consider '/' to be a word break) by setting the third
-- entry in the Command tuple above.
--
-- NOTE: in order for us to override the default correctly, any custom entry
-- must be a SUBSET of word_break_chars.
-- #if defined(mingw32_HOST_OS)
--         win <- System.Win32.getWindowsDirectory
--         return (win </> "notepad.exe")
-- #else
--         return ""
-- #endif
-- HACK! If we happen to get into an infinite loop (eg the user
-- types 'let x=x in x' at the prompt), then the thread will block
-- on a blackhole, and become unreachable during GC.  The GC will
-- detect that it is unreachable and send it the NonTermination
-- exception.  However, since the thread is unreachable, everything
-- it refers to might be finalized, including the standard Handles.
-- This sounds like a bug, but we don't have a good solution right
-- now.
-- Initialise buffering for the *interpreted* I/O system
-- The initial set of DynFlags used for interactive evaluation is the same
-- as the global DynFlags, plus -XExtendedDefaultRules and
-- -XNoMonomorphismRestriction.
-- Only for GHCi (not runghc and ghc -e):
-- Turn buffering off for the compiled program's stdout/stderr
-- Turn buffering off for GHCi's stdout
-- We don't want the cmd line to buffer any input that might be
-- intended for the program, so unbuffer stdin.
-- #if defined(mingw32_HOST_OS)
--         -- On Unix, stdin will use the locale encoding.  The IO library
--         -- doesn't do this on Windows (yet), so for now we use UTF-8,
--         -- for consistency with GHC 6.10 and to make the tests work.
--         liftIO $ hSetEncoding stdin utf8
-- #endif
-- We initialize line number as 0, not 1, because we use
-- current line number while reporting errors which is
-- incremented after reading a line.
-- NOTE: this assumes that runInputT won't affect the terminal;
-- can we assume this will always be the case?
-- This would be a good place for runFileInputT.
-- Don't print a message if this is really ghc -e (#11478).
-- Also, let the user silence the message with -v0
-- (the default verbosity in GHCi is 1).
--
-- -ghci-script are collected in reverse order
-- We don't require that a script explicitly added by -ghci-script
-- is owned by the current user. (#6017)
-- nub, because we don't want to read .ghci twice if the CWD is $HOME.
-- Perform a :load for files given on the GHCi command line
-- When in -e mode, if the load fails then we want to stop
-- immediately rather than going on to evaluate the expression.
-- TODO: this is a hack.
-- if verbosity is greater than 0, or we are connected to a
-- terminal, display the prompt in the interactive loop.
-- reset line number
-- enter the interactive loop
-- just evaluate the expression we were given
-- flush the interpreter's stdout/stderr on exit (#3890)
-- Jump through some hoops to get the
-- current progname in the exception text:
-- <progname>: <exception>
-- this used to be topHandlerFastExit, see #2228
-- make `ghc -e` exit nonzero on invalid input, see Trac #7962
-- and finally, exit
-- | How to get the next input line from the user
-- NOTE: We only read .ghci files if they are owned by the current user,
-- and aren't world writable (files owned by root are ok, see #9324).
-- Otherwise, we could be accidentally running code planted by
-- a malicious third party.
-- Furthermore, We only read ./.ghci if . is owned by the current user
-- and isn't writable by anyone else.  I think this is sufficient: we
-- don't need to check .. and ../.. etc. because "."  always refers to
-- the same directory while a process is running.
-- Do not check dir perms when .ghci doesn't exist, otherwise GHCi will
-- print some confusing and useless warnings in some cases (e.g. in
-- travis). Note that we can't add a test for this, as all ghci tests should
-- run with -ignore-dot-ghci, which means we never get here.
-- #if defined(mingw32_HOST_OS)
-- checkPerms _ = return True
-- #else
-- checkPerms file =
--   handleIO (\_ -> return False) $ do
--     st <- getFileStatus file
--     me <- getRealUserID
--     let mode = System.Posix.fileMode st
--         ok = (fileOwner st == me || fileOwner st == 0) &&
--              groupWriteMode /= mode `intersectFileModes` groupWriteMode &&
--              otherWriteMode /= mode `intersectFileModes` otherWriteMode
--     unless ok $
--       -- #8248: Improving warning to include a possible fix.
--       putStrLn $ "*** WARNING: " ++ file ++
--                  " is writable by someone else, IGNORING!" ++
--                  "\nSuggested fix: execute 'chmod go-w " ++ file ++ "'"
--     return ok
-- #endif
-- as we share stdin with the program, the program
-- might have already closed it, so we might get a
-- handle-closed exception. We therefore catch that
-- too.
-- treat InvalidArgument in the same way as EOF:
-- this can happen if the user closed stdin, or
-- perhaps did getContents which closes stdin at
-- EOF.
-- #if defined(mingw32_HOST_OS)
--   getEnv "USERNAME"
--     `catchIO` \e -> do
--       putStrLn $ show e
--       return ""
-- #else
--   getLoginName
-- #endif
-- rightmost are the most recent
-- Reconfigurable pretty-printing Ticket #5461
-- | The main read-eval-print loop
-- ^ Exception handler
-- ^ Source error handler
-- We want to return () here, but have to return (Maybe Bool)
-- because gmask is not polymorphic enough: we want to use
-- unmask at two different types.
-- | Evaluate a single line of user input (either :<command> or Haskell code).
-- A result of Nothing means there was no more input to process.
-- Otherwise the result is Just b where b is True if the command succeeded;
-- this is relevant only to ghc -e, which will exit with status 1
-- if the command was unsuccessful. GHCi will continue in either case.
-- run a previously queued command if there is one, otherwise get new
-- input from user
-- source error's are handled by runStmt
-- is the handler necessary here?
-- Exit ghc -e, but not GHCi
-- we can't use removeSpaces for the sublines here, so
-- multiline commands are somewhat more brittle against
-- fileformat errors (such as \r in dos input on unix),
-- we get rid of any extra spaces for the ":}" test;
-- we also avoid silent failure if ":}" is not found;
-- and since there is no (?) valid occurrence of \r (as
-- opposed to its String representation, "\r") inside a
-- ghci command, we replace any such with ' ' (argh:-(
-- SDM (2007-11-07): is userError the one to use here?
-- | Handle a line of input
-- command
-- haskell
-- if 'stmt' was entered via ':{' it will contain '\n's
-- don't trigger automatic multi-line mode for ':{'-multiline input
-- temporarily compensate line-number for multi-line input
-- single line input and :{ - multiline input
-- reconstruct first line num from last line num and stmt
-- single line input
-- runStmt doesn't like leading empty lines
-- temporarily compensate line-number for multi-line input
-- runStmt wrapper for temporarily overridden line-number
-- restore original line_number
-- note: this is subtly different from 'unlines . dropWhile (all isSpace) . lines'
-- #4316
-- lex the input.  If there is an unclosed layout context, request input
-- the recursive call does not recycle parser state
-- as we use a new string buffer
-- make sure we force any exceptions in the commands while we're
-- still inside the exception handler, otherwise bad things will
-- happen (see #10501)
-- | Entry point to execute some haskell code from user.
-- The return value True indicates success, as in `runOneCommand`.
-- In GHCi, we disable `-fdefer-type-errors`, as well as `-fdefer-type-holes`
-- and `-fdefer-out-of-scope-variables` for **naked expressions**. The
-- declarations and statements are not affected.
-- See Note [Deferred type errors in GHCi] in typecheck/TcRnDriver.hs
-- Every import declaration should be handled by `run_import`. As GHCi
-- in general only accepts one command at a time, we simply throw an
-- exception when the input contains multiple commands of which at least
-- one is an import command (see #10663).
-- Note: `GHC.isDecl` returns False on input like
-- `data Infix a b = a :@: b; infixl 4 :@:`
-- and should therefore not be used here.
-- In the new IO library, read handles buffer data even if the Handle
-- is set to NoBuffering.  This causes problems for GHCi where there
-- are really two stdin Handles.  So we flush any bufferred data in
-- GHCi's stdin Handle here (only relevant if stdin is attached to
-- a file, otherwise the read buffer can't be flushed).
-- | Clean up the GHCi environment after a statement has run
-- run the command set with ":set stop <cmd>"
--  printTypeOfNames session names
-- | Entry point for execution a ':<command>' input from user
-- "::" selects a builtin command
-- otherwise include macros in lookup
-- hidden commands can only be matched exact
-- first, look for exact match (while preferring macros); then, look
-- for first prefix match (preferring builtins), *unless* a macro
-- overrides the builtin; see #8305 for motivation
-----------------------------------------------------------------------------
--
-- Commands
--
-----------------------------------------------------------------------------
-----------------------------------------------------------------------------
-- :help
-----------------------------------------------------------------------------
-- :info
-- Filter out names whose parent is also there Good
-- example is '[]', which is both a type and data
-- constructor in the same type
-----------------------------------------------------------------------------
-- :main
-- Wrap the main function in 'void' to discard its value instead
-- of printing it (#9086). See Haskell 2010 report Chapter 5.
-----------------------------------------------------------------------------
-- :run
-----------------------------------------------------------------------------
-- :cd
-- :cd on its own changes to the user's home directory
-- With -fexternal-interpreter, we have to change the directory of the subprocess too.
-- (this gives consistent behaviour with and without -fexternal-interpreter)
-----------------------------------------------------------------------------
-- :edit
-- The user didn't specify a file so we pick one for them.
-- Our strategy is to pick the first module that failed to load,
-- or otherwise the first target.
--
-- XXX: Can we figure out what happened if the depndecy analysis fails
--      (e.g., because the porgrammeer mistyped the name of a module)?
-- XXX: Can we figure out the location of an error to pass to the editor?
-- XXX: if we could figure out the list of errors that occured during the
-- last load/reaload, then we could start the editor focused on the first
-- of those.
-- when would we get a module target?
-----------------------------------------------------------------------------
-- :def
{-overwrite-}
-- compile the expression
-- > ghciStepIO . definition :: String -> IO String
-- later defined macros have precedence
{-String -> IO String-}
-----------------------------------------------------------------------------
-- :undef
-- This is a tad racy but really, it's a shell
-----------------------------------------------------------------------------
-- :cmd
-- > ghciStepIO str :: IO String
-- | Generate a typed ghciStepIO expression
-- @ghciStepIO :: Ty String -> IO String@.
-----------------------------------------------------------------------------
-- :check
-----------------------------------------------------------------------------
-- :doc
-- TODO: Maybe also get module headers for module names
-- TODO: also print arg docs.
-----------------------------------------------------------------------------
-- :load, :add, :reload
-- | Sets '-fdefer-type-errors' if 'defer' is true, executes 'load' and unsets
-- '-fdefer-type-errors' again if it has not been set before.
-- Force originalFlags to avoid leaking the associated HscEnv
-- | @:load@ command
-- NOTE: we used to do the dependency anal first, so that if it
-- fails we didn't throw away the current set of modules.  This would
-- require some re-working of the GHC interface, so we'll leave it
-- as a ToDo for now.
-- Grab references to the currently loaded modules so that we can
-- see if they leak.
-- unload first
-- | @:add@ command
-- always revert CAFs on load/add.
-- remove old targets with the same id; e.g. for :add *M
-- | @:unadd@ command
-- | @:reload@ command
-- | Load/compile targets and (optionally) collect module-info
--
-- This collects the necessary SrcSpan annotated type information (via
-- 'collectInfo') required by the @:all-types@, @:loc-at@, @:type-at@,
-- and @:uses@ commands.
--
-- Meta-info collection is not enabled by default and needs to be
-- enabled explicitly via @:set +c@.  The reason is that collecting
-- the type-information for all sub-spans can be quite expensive, and
-- since those commands are designed to be used by editors and
-- tooling, it's useless to collect this data for normal GHCi
-- sessions.
-- doLoad retain_context howmuch >>= \case
-- turn off breakpoints before we load: we can't turn them off later, because
-- the ModBreaks will have gone away.
-- Enable buffering stdout and stderr as we're compiling. Keeping these
-- handles unbuffered will just slow the compilation down, especially when
-- compiling in parallel.
-- keep the remembered_ctx, as far as possible (:reload)
-- always revert CAFs on load.
-- load a target if one is available, otherwise load the topmost module.
-- We import the module with a * iff
--   - it is interpreted, and
--   - -XSafe is off (it doesn't allow *-imports)
-- | Keep any package modules (except Prelude) when changing the context.
-- True  <=> keep all of remembered_ctx
-- False <=> just keep package imports
-- new context
-- | Filters a list of 'InteractiveImport', clearing out any home package
-- imports so only imports from external packages are preserved.  ('IIModule'
-- counts as a home package import, because we are only able to bring a
-- full top-level into scope when the source is available.)
-- Fix #9887
-- | Run an 'ExceptT' wrapped 'GhcMonad' while handling source errors
-- and printing 'throwE' strings to 'stderr'
-- | Inverse of 'runExceptT' for \"pure\" computations
-- (c.f. 'except' for 'Except')
-----------------------------------------------------------------------------
-- | @:type@ command. See also Note [TcRnExprMode] in TcRnDriver.
-----------------------------------------------------------------------------
-- | @:type-at@ command
-----------------------------------------------------------------------------
-- | @:uses@ command
-----------------------------------------------------------------------------
-- | @:loc-at@ command
-----------------------------------------------------------------------------
-- | @:all-types@ command
-----------------------------------------------------------------------------
-- Helpers for locAtCmd/typeAtCmd/usesCmd
-- | Parse a span: <module-name/filepath> <sl> <sc> <el> <ec> <string>
-- | Pretty-print \"real\" 'SrcSpan's as
-- @<filename>:(<line>,<col>)-(<line-end>,<col-end>)@
-- while simply unpacking 'UnhelpfulSpan's
-- | Variant of 'showSrcSpan' for 'RealSrcSpan's
-----------------------------------------------------------------------------
-- | @:kind@ command
-----------------------------------------------------------------------------
-- :quit
-----------------------------------------------------------------------------
-- :script
-- running a script file #1363
-- ^ filename
-----------------------------------------------------------------------------
-- :issafe
-- Displaying Safe Haskell properties of a module
-- print info to user...
-----------------------------------------------------------------------------
-- :browse
-- Browsing a module's contents
-- Guess which module the user wants to browse.  Pick
-- modules that are interpreted first.  The most
-- recently-added module occurs last, it seems.
-- without bang, show items in context of their parents and omit children
-- with bang, show class methods and data constructors separately, and
--            indicate import modules, to aid qualifying unqualified names
-- with sorted, sort items alphabetically
-- :browse reports qualifiers wrt current context
-- sort alphabetically name, but putting locally-defined
-- identifiers first. We would like to improve this; see #1799.
-- try to sort by src location. If the first name in our list
-- has a good source location, then they all should.
-- annotate groups of imports with their import modules
-- the default ordering is somewhat arbitrary, so we group
-- by header and sort groups; the names themselves should
-- really come in order of source appearance.. (trac #1799)
-- ToDo: modInfoInstances currently throws an exception for
-- package modules.  When it works, we can do this:
--        $$ vcat (map GHC.pprInstance (GHC.modInfoInstances mod_info))
-----------------------------------------------------------------------------
-- :module
-- Setting the module context.  For details on context handling see
-- "remembered_ctx" and "transient_ctx" in GhciMonad.
-- -----------------------------------------------------------------------------
-- Four ways to manipulate the context:
--   (a) :module +<stuff>:     addModulesToContext
--   (b) :module -<stuff>:     remModulesFromContext
--   (c) :module <stuff>:      setContext
--   (d) import <module>...:   addImportToContext
-- we do *not* call restoreContextOnFailure here.  If the user
-- is trying to fix up a context that contains errors by removing
-- modules, we don't want GHC to silently put them back in again.
-- delete the transient context
-- #5836
-- Util used by addImportToContext and addModulesToContext
-- Sometimes we can't tell whether an import is valid or not until
-- we finally call 'GHC.setContext'.  e.g.
--
--   import System.IO (foo)
--
-- will fail because System.IO does not export foo.  In this case we
-- don't want to store the import in the context permanently, so we
-- catch the failure from 'setGHCContextFromGHCiState' and set the
-- context back to what it was.
--
-- See #6007
--
-- -----------------------------------------------------------------------------
-- Validate a module that we want to add to the context
-- -----------------------------------------------------------------------------
-- Update the GHC API's view of the context
-- | Sets the GHC context from the GHCi state.  The GHC context is
-- always set this way, we never modify it incrementally.
--
-- We ignore any imports for which the ModuleName does not currently
-- exist.  This is so that the remembered_ctx can contain imports for
-- modules that are not currently loaded, perhaps because we just did
-- a :reload and encountered errors.
--
-- Prelude is added if not already present in the list.  Therefore to
-- override the implicit Prelude import you can say 'import Prelude ()'
-- at the prompt, just as in Haskell source.
--
-- re-use checkAdd to check whether the module is valid.  If the
-- module does not exist, we do *not* want to print an error
-- here, we just want to silently keep the module in the context
-- until such time as the module reappears again.  So we ignore
-- the actual exception thrown by checkAdd, using tryBool to
-- turn it into a Bool.
-- allow :seti to override -XNoImplicitPrelude
-- We add the prelude imports if there are no *-imports, and we also
-- allow each prelude import to be subsumed by another explicit import
-- of the same module.  This means that you can override the prelude import
-- with "import Prelude hiding (map)", for example.
-- -----------------------------------------------------------------------------
-- Utils on InteractiveImport
-- we only care about imports here
-- | @filterSubsumed is js@ returns the elements of @js@ not subsumed
-- by any of @is@.
-- | Returns True if the left import subsumes the right one.  Doesn't
-- need to be 100% accurate, conservatively returning False is fine.
-- (EXCEPT: (IIModule m) *must* subsume itself, otherwise a panic in
-- plusProv will ensue (#5904))
--
-- Note that an IIModule does not necessarily subsume an IIDecl,
-- because e.g. a module might export a name that is only available
-- qualified within the module itself.
--
-- Note that 'import M' does not necessarily subsume 'import M(foo)',
-- because M might not export foo and we want an error to be produced
-- in that case.
--
-- A bit crude
----------------------------------------------------------------------------
-- :set
-- set options in the interpreter.  Syntax is exactly the same as the
-- ghc command line, except that certain options aren't available (-C,
-- -E etc.)
--
-- This is pretty fragile: most options won't work as expected.  ToDo:
-- figure out which ones & disallow them.
-- We explicitly annotate the type of the expression to ensure
-- that unsafeCoerce# is passed the exact type necessary rather
-- than a more general one
-- first, deal with the GHCi opts (+s, +t, etc.)
-- then, dynamic flags
-- Load any new plugins
-- if the package flags changed, reset the context and link
-- the new packages.
-- package flags changed, we can't re-use any of the old context
-- and copy the package state to the interactive DynFlags
-- first, deal with the GHCi opts (+s, +t, etc.)
-- ---------------------------------------------------------------------------
-- :show
-- (show in help?, command name, action)
-- backwards compat
-- useful abbreviation
-- backwards compat
-- useful abbreviation
--
-- we want *loaded* modules only, see #1734
-- #12525
-- See Note [Filter bindings]
-- reverse so the new ones come last
{-
Note [Filter bindings]
~~~~~~~~~~~~~~~~~~~~~~

If we don't filter the bindings returned by the function GHC.getBindings,
then the :show bindings command will also show unwanted bound names,
internally generated by GHC, eg:
    $tcFoo :: GHC.Types.TyCon = _
    $trModule :: GHC.Types.Module = _ .

The filter was introduced as a fix for Trac #12525 [1]. Comment:1 [2] to this
ticket contains an analysis of the situation and suggests the solution
implemented above.

The same filter was also implemented to fix Trac #11051 [3]. See the
Note [What to show to users] in compiler/main/InteractiveEval.hs

[1] https://ghc.haskell.org/trac/ghc/ticket/12525
[2] https://ghc.haskell.org/trac/ghc/ticket/12525#comment:1
[3] https://ghc.haskell.org/trac/ghc/ticket/11051
-}
-- -----------------------------------------------------------------------------
-- Completion
-- syntax: [n-][m] with semantics "drop (n-1) . take m"
-- upper limit only
-- | Provide completions for last word in a given string.
--
-- Takes a tuple of two strings.  First string is a reversed line to be
-- completed.  Second string is likely unused, 'completeCmd' always passes an
-- empty string as second item in tuple.
-- If given string starts with `:` colon, and there is only one following
-- word then provide REPL command completions.  If there is more than one
-- word complete either filename or builtin ghci commands or macros.
-- If given string starts with `import` keyword provide module name
-- completions
-- otherwise provide identifier completions
-- Note: `left` is a reversed input
-- | Return a list of visible module names for autocompletion.
-- (NB: exposed != visible)
-- -----------------------------------------------------------------------------
-- commands for debugger
-- | Returns the span of the largest tick containing the srcspan given
-- doContinue :: SingleStep -> GHCi ()
-- the prompt will change to indicate the new context
-- delete all break points
-- run the command set with ":set stop <cmd>"
-- run the command set with ":set stop <cmd>"
-- handle the "break" command
-- try parsing it as an identifier
-- looks like a line number
-- When a line number is specified, the current policy for choosing
-- the best breakpoint is this:
--    - the leftmost complete subexpression on the specified line, or
--    - the leftmost subexpression starting on the specified line, or
--    - the rightmost subexpression enclosing the specified line
--
-- The aim is to find the breakpoints for all the RHSs of the
-- equations corresponding to a binding.  So we find all breakpoints
-- for
--   (a) this binder only (not a nested declaration)
--   (b) that do not have an enclosing breakpoint
-- the ticks that span this coordinate
-- For now, use ANSI bold on terminals that we know support it.
-- Otherwise, we add a line of carets under the active expression instead.
-- In particular, on Windows and when running the testsuite (which sets
-- TERM to vt100 for other reasons) we get carets.
-- We really ought to use a proper termcap/terminfo library.
-----------------------------------------------------------------------------
-- :where
-----------------------------------------------------------------------------
-- :list
-- | list a section of a source file around a particular SrcSpan.
-- If the highlight flag is True, also highlight the span using
-- start_bold\/end_bold.
-- GHC files are UTF-8, so we can implement this by:
-- 1) read the file in as a BS and syntax highlight it as before
-- 2) convert the BS to String using utf-string, and write it out.
-- It would be better if we could convert directly between UTF-8 and the
-- console encoding, of course.
-- Drop carriage returns to avoid duplicates, see #9367.
-- --------------------------------------------------------------------------
-- Tick arrays
-- don't reset the counter back to zero?
-- ---------------------------------------------------------------------------
-- User code exception handling
-- This is the exception handler for exceptions generated by the
-- user's code and exceptions coming from children sessions;
-- it normally just prints out the exception.  The
-- handler must be recursive, in case showing the exception causes
-- more exceptions to be raised.
--
-- Bugfix: if the user closed stdout or stderr, the flushing will fail,
-- raising another exception.  We therefore don't put the recursive
-- handler arond the flushing operation, so if stderr is closed
-- GHCi will just die gracefully rather than going into an infinite loop.
-- omit the location for CmdLineError:
-- ditto:
-----------------------------------------------------------------------------
-- recursive exception handlers
-- Don't forget to unblock async exceptions in the handler, or if we're
-- in an exception loop (eg. let a = error a in a) the ^C exception
-- may never be delivered.  Thanks to Marcin for pointing out the bug.
-- Force dflags to avoid leaking the associated HscEnv
-- ----------------------------------------------------------------------------
-- Utils
-- TODO: won't work if home dir is encoded.
-- (changeDirectory may not work either in that case.)
-- will fail if HOME not defined
