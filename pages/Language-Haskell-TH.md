# Language.Haskell.TH

template-haskellはHaskellのマクロを提供する。マクロはHaskellの構文木(AST)をプログラムによって生成し、コンパイル時にそれを実際のプログラム中に挿入することができる。

[Language.Haskell.TH.Syntax](https://www.stackage.org/haddock/lts-12.7/template-haskell-2.13.0.0/Language-Haskell-TH-Syntax.html)では、Haskell(GHC)のsyntaxがADTを用いて表現されている。

### Q Monad

Qモナドはマクロの評価を表すモナドである。

- `Q a`
    - Qモナドは`MonadIO`のインスタンスをもつ
    - `runQ :: IO a -> Q a`: こちらによってもIOアクションをQモナドにliftできる。これにより、副作用を持つプログラムの実行をコンパイル時に引き起こすことが可能である
- `Name`
    - `Name`はAST中の変数などを参照する際に使用される名前を表す
    - 関数(変数)名および型名を表す`Name`は、`'f`および`''T`などの記法により得ることができる
    - `mkName :: String -> Name`: 指定した文字列に一致する参照を取得する。外部のモジュールからインポートされた関数への参照は完全修飾を名前として用いる。例: `Prelude.pi`
    - `newName :: String -> Q Name`: 新しい変数名を確保する。引数に渡した文字列をもとに変数名を決定するが、実際には適当なソルトがつくので名前がそのまま使われるわけではない
    - `reify :: Name -> Q Info`: 定義されている変数などの名前からそれについての情報を得る。これにより、与えられた名前がデータコンストラクタなのか、型クラスのメソッドなのか、などを得ることができる。
        - `Info`のブランチには`VarI Name Type (Maybe Dec)`があり、関数名、型、関数本体が得られることが期待されるが、GHC8.4の時点で関数本体は常に`Nothing`が返ることになっている

### Splices and Quotes

- マクロをASTに挿入する際には`$(..)`のsyntaxを用いる(spliceとよぶ)。`$(..)`の中身の型により4種類のマクロになる
    - `Q Exp`: 式マクロ。syntaxの式(`Exp`)の位置に挿入可能である
    - `Q Pat`: パターンマクロ。パターンマッチなど、パターンの位置に挿入可能である
    - `Q Type`: 型マクロ。型の位置に挿入可能である
    - `Q Dec`: 宣言マクロ。宣言を置く位置(トップレベル)に挿入可能である。このマクロはspliceを省略して直接`Q Dec`の値を置くことができる
        - `Dec`は関数宣言やデータ型宣言などからなるが、ここに式が来ることはない。よってGHCはトップレベルで式を見たらそれはspliceの省略された形であると理解することができる。
- 逆にHaskellのプログラムを表す文字列を実際のASTの値に変換するためには`[|..|]`のsyntaxを用いる(quoteとよぶ)。quoteもspliceと同じく4種類ある
    - `[e| .. |]`: 式クォート。中に式を置き、全体は`Q Exp`型の値になる。このクォートは`e`の部分を省略して`[|..|]`と書くことが可能である。
    - `[p| .. |]`: パターンクォート
    - `[t| .. |]`: 型クォート
    - `[d| .. |]`: 宣言クォート

