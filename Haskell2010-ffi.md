# Foreign Function Interface (外部関数インターフェイス)

外部関数インターフェイス(FFI)には 2 つの目的がある。1 つ目は Haskell の中で外部言語の機能に対するインターフェイスを提供することで、2 つ目は Haskell が行う仕事を外部コードから利用することである。より一般的には、Haskell とほかの言語が混合したプログラムの実装をサポートし、それによってソースコードが Haskell の他の実装と Haskell 以外のシステムにわたって移植性可能になり、さらにアーキテクチャと OS からも独立となる。

### 外部言語

Haskell の FFI は現在のところ Haskell コードと C 言語の呼び出し規約の従った外部コードの間のやりとりのみを対象としている。しかし、FFI のデザインは C++や Java といったほかのプログラミング言語の呼び出し規約も含められるように現在の定義を組み合わせられる形で拡張することを可能にするようなものである。他の言語へのサポートの正確な定義はこの言語の今後のバージョンに含まれることが期待される。次に大きく省略されたのは外部言語のマルチスレッドとのやりとり、特にスレッドローカルな状態の扱いであり、そしてそれらの詳細は現時点では実装依存である。

現在の仕様のコアは Haskell と接続するのに使われる外部言語とは独立である。しかし、FFI の仕様が言語依存でなければならないところが 2 箇所ある: (1)外部の名前の仕様と(2)外部言語の基本型のマーシャリングである。前者の例としては、C 言語においては単純な識別子でオブジェクトを識別するのに十分[9]であるのに対し、Java では一般に、引数に併せて修飾子付きの名前と、起こりうるオーバーローディングを解決するために結果の型が必要である[5]。2 つ目のポイントに関しては、一部の基本型に対してその完全な表現を指定しない多くの言語を考えてみよ。例えば C 言語の型`int`は 16 または 32 または 64bit の長さをもつ。同様に、Haskell は`Int`が少なくとも`[-2^29,2^29-1]`(セクション 6.4 を見よ)の範囲をカバーすることしか保証しない。その結果として C 言語の`int`型の値を Haskell で信頼できる形で表現するためには、`int`の表現に適合することが保証されている新しい型`CInt`を導入するしかない。

呼び出し規約に依存する、外部の名前の仕様はセクション 8.5 で説明される。また、外部言語に依存する基本型のマーシャリングはセクション 8.6 で説明される。

### コンテキスト

Haskell のシステムが与えられたとき、**Haskell のコンテキスト**とは、Haskell システムを支える抽象マシンの実行コンテキストのことと定義する。これはヒープ、スタック、そして抽象マシンのレジスタとそれらの具体的なアーキテクチャへの対応付けを含む。それ以外の任意の実行コンテキストを**外部コンテキスト**と呼ぶ。一般に、Haskell が明示的に規定した特別なデータフォーマットを除いては、Haskell コンテキストと与えられている外部コンテキストの間でデータフォーマット及び呼び出し規約のどんな互換性も仮定しない。

外部関数インターフェイスの主な目標は Haskell のコンテキストと外部コンテキストの間のプログラム可能なインターフェイスを提供することである。結果として Haskell スレッドは外部コンテキストのデータにアクセスし、外部コンテキストで実行された関数を呼び出すことができ、さらにその逆もできる。本定義の残りの部分から、外部コンテキストは通常呼び出し規約によって識別される。

#### 言語を跨いだ型の一貫性

静的型をサポートした多くの外部言語が与えられているとき、Haskell の型と外部言語の型の一貫性を外部関数に対しても強制できるかどうかという疑問が出てくる。残念なことに、これは一般に、Haskell システムの実装の側に大変に特別な仕組みをあらかじめ用意しておかなければ不可能である(すなわち、専用の型チェッカーを実装するなどをしない場合)。例えば、C の呼び出し規約の場合では、Haskell の型から C のプロトタイプ宣言を生成し、インポートされた関数に対して C コンパイラに C のヘッダーファイルで指定されたプロトタイプと合致させることを C コンパイラに任せるのが唯一の他の方法である。しかし Haskell の型にはこの方法を追及するために必要とされる情報が揃っていない。特に、Haskell の型はいつ`const`修飾子が付けられるべきかについての情報を含んでいない。

結果として、この定義は Haskell システムで外部型との一貫性をチェックすることを必要としない。しかしながら、Haskell システムはほどよい努力で実装可能な言語を跨いだ一貫性チェックを提供することが推奨されている。

### 字句構造

FFI は`foreign`なる単一のキーワードと特別な識別子の集合を予約する。後者は foreign 宣言の中でのみ特別な意味を持つが、他の場所では一般的な識別子としても使われることがある。

特別な識別子は`ccall, cplusplus, dotnet, jvm, stdcall`が呼び出し規約を表現するために定義されている。しかし個々の FFI の実装がここに挙げられていないシステム独自の呼び出し規約を追加で実装することに関しては自由である。

外部 C コンテキストのオブジェクトを参照するために、次の語句を導入する:

```haskell
chname	→	{chchar} . h    	    (C header filename)
cid	→	letter {letter | ascDigit}  (C identifier)
chchar	→	letter | ascSymbol⟨&⟩
letter	→	ascSmall | ascLarge | _
```

`chname`が認められているトークンの範囲は、C の`#include`ディレクティブの引数として許されているもののサブセットである。特に、`chname`を名前に持つファイルは`.h`の接尾辞を付けなければならない。`cid`によって生成されたトークンは[9]で指定されているような、C の識別子として許されているもの全体と一致する。。

### foreign 宣言

foreign 宣言の文法は次のようになる:

```haskell
topdecl	    →	'foreign' fdecl
fdecl	    →	'import' callconv [safety] impent var '::' ftype   (define variable)
            |	'export' callconv expent var '::' ftype	           (expose variable)
callconv    →	'ccall' | 'stdcall' | 'cplusplus'                  (calling convention)
            |	'jvm' | 'dotnet'
            |	system-specific calling conventions
impent	    →	[string]
expent	    →	[string]
safety	    →	'unsafe' | 'safe'
```

foreign 宣言には 2 つの種類がある: import 宣言と export 宣言である。import 宣言は**外部エンティティ**すなわち外部コンテキストで定義され、Haskell コンテキストで利用可能な関数やメモリ番地を作成する。逆に、export 宣言は Haskell コンテキストの関数を外部コンテキストの外部エンティティとして定義する。結論として、これらの宣言の 2 つの種類は import 宣言が新しい変数を定義するのに対し、export 宣言は Haskell のモジュールですでに定義されている変数を用いるという点で異なる。

外部エンティティを含む外部コンテキストは foreign 宣言で与えられた呼び出し規約によって決定される。結果として、外部エンティティの仕様の完全な形は呼び出し規約とそれが import 宣言に(impent として)出現するか、export 宣言に(expent として)出現するかの両方に依存する。異なる呼び出し規約がある状態でも文法の一様性を提供するため、外部エンティティの説明が Haskell の文字列語句として出現することが保証されている。唯一の例外はこの文字列が空文字列であるとき(すなわち`""`の形をしているとき)で、この場合は文字列は全体で省略されることもある。

#### 呼び出し規約

与えられたアーキテクチャにおける外部エンティティへのバイナリーインターフェイスは呼び出し規約によって決定される。これはしばしば外部エンティティが実装したプログラミング言語にも依存するが、外部エンティティがコンパイルされたシステムにより強く依存するのが普通である。

呼び出し規約がプログラミング言語よりもシステムに支配されることの例としては、Java 仮想マシン(JVM)[11]のバイトコードへコンパイルされたエンティティが、実装を書いたソース言語(エンティティは Oberon によって実装されている)の規則ではなく JVM の規則に従う必要があるということがある。

Haskell の FFI の実装は最低でも`ccall`を用いて表示された C 言語の呼び出し規約を実装しなければならない。それ以外の呼び出し規約は任意である。一般に、呼び出し規約の集合はオープンである、すなわち、実装によっては追加で呼び出し規約をサポートすることを選んでいるものもある。`ccall`に加えて、表 8.1 に代表的な呼び出し規約の識別子を並べてある。

| 識別子      | それが表現する呼び出し規約                      |
| ----------- | ----------------------------------------------- |
| `ccall`     | システムの標準的な C コンパイラの呼び出し規約   |
| `cplusplus` | システムの標準的な C++コンパイラの呼び出し規約  |
| `dotnet`    | .NET プラットフォームの呼び出し規約             |
| `jvm`       | Java 仮想マシンの呼び出し規約                   |
| `stdcall`   | (Pascal 規約に適合した)Win32 API の呼び出し規約 |

表 8.1 呼び出し規約

実装はこれらの規約をすべて実装する必要はないが、これらのうちいずれかを実装するのであれば上に列挙された名前を使わなければならない。他の呼び出し規約に対しては、実装は適した名前を選ぶ自由がある。

ここでは`ccall`と`stdcall`の呼び出し規約の意味だけが定義される。より多くの呼び出し規約は Haskell の将来的なバージョンで追加されるかもしれない。

特定の呼び出し規約を実装するためには、Haskell システムによって生成されたコードがシステムのターゲットコードによって大きく変動する可能性があることに注意しよう。例えば、呼び出し規約`jvm`は明らかに、Java ネイティブインターフェイス(JNI)[10]をターゲットとするような Java コードを生成する Haskell コンパイラのために実装されるが、C コードを生成する Haskell コンパイラのために実装される。

#### 外部型

**基本外部型**の集合は次のような型によって構成される:

- `Char`, `Int`, `Double`, `Float`, `Bool`は Haskell の`Prelude`によってエクスポートされるものと同じである
- `Int8`, `Int16`, `Int32`, `Int64`, `Word8`, `Word16`, `Word32`, `Word64`, 任意の型`a`に対しての`Ptr a`, `FunPtr a`, `StablePtr a`は`Foreign` (セクション 24)によってエクスポートされているものである

FFI を実装する Haskell システムは関数の引数及び戻り値として Haskell と外部コンテキストの間でこれらの型がやり取りできるようにするべきである。

外部型は次のような文法によって生成される:

```haskell
ftype	→   frtype
        |   fatype  →  ftype
frtype	→   fatype
        |   ()
fatype	→   qtycon atype1 … atypek  (k ≥ 0)
```

外部型は外部エンティティの Haskell における型である。Haskell の型のサブセットのみが外部型として許されており、型を制限したある集合のみが標準的な仕方で Haskell コンテキストと外部コンテキストの間で転送することができる。外部型は`at1 -> ⋅⋅⋅ -> atn -> rt` (`n ≥ 0`)の形をしている。これは外部エンティティの引数が`n`であることを表している。

外部関数はすべての引数に対して正格である。

**マーシャリング可能な外部型** `fatype`によって生成される引数型`ati`は **マーシャリング可能な外部型** でなければならない。つまり、次のいずれかである:

- 基本外部型
- 型シノニムで、マーシャリング可能な外部型へ展開されるもの
- 型`T t1' ... tn'` ただし`T`は`newtype`宣言 `newtype T a1 .. an = N t` によって定義されたものであって、
  - コンストラクター`N`は`T`が使われるところで可視であり、
  - `t[t1'/a1 .. tn'/an]`はマーシャリング可能な外部型である

結果として、`newtype`によって定義された型をそれが定義されたモジュールの外の`foreign`宣言の中で利用するためには、型が抽象的にエクスポートされていてはならない。`Foreign.C.Types`モジュールで定義している C の型と等価な Haskell はこの慣習に従っている。チャプター 28 を見よ。

**マーシャリング可能な外部戻り値型** `frtype`によって生成された戻り値型`rt`は **マーシャリング可能な外部戻り値型** でなければならない。つまり、次のいずれかである:

- 型`()`
- `Prelude.IO`にマッチする型`t`、ただし`t`はマーシャリング可能な外部型であるか`()`のいずれか
- 基本外部型
- 型シノニムで、マーシャリング可能な外部戻り値型に展開されるもの
- 型`T t1' ... tn'` ただし`T`は`newtype`宣言 `newtype T a1 ... an = N t` によって定義されたものであり、
  - コンストラクター`N`は`T`が使われるところで可視であり、
  - `t[t1'/a1 .. tn'/an]`はマーシャリング可能な外部戻り値型である

#### import 宣言

一般的に、import 宣言は `foreign import c e v :: t` のような形で、これは外部で定義された型`t`を持つ変数`v`を宣言していてる。さらに、`v`は呼び出し規約`c`を用いて文字列`e`で識別される外部エンティティを実行することで評価されることまで宣言されている。`e`の正確な形は呼び出し規約に依存する。詳しくはセクション 8.5 で説明される。変数`v`が import 宣言によって定義されているならば、同じモジュールで`v`に対するどんなトップレベル宣言も許されない。例えば、次の宣言は関数`cstrlen`を導入し、そしてこの関数は外部関数`strlen`を標準的な C 言語呼び出し規約を用いて呼び出す:

```haskell
foreign import ccall "string.h strlen"
    cstrlen :: Ptr CChar -> IO CSize
```

外部エンティティを純粋関数として import できる場合もある。例えば:

```haskell
foreign import ccall "math.h sin"
    sin :: CDouble -> CDouble
```

このような宣言は外部エンティティが真の関数であることを仮定している。すなわち、同じ値を引数として適用すれば必ず同じ結果を返すという性質である。
