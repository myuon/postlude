# Foreign Function Interface (外部関数インターフェイス)

外部関数インターフェイス(FFI)には2つの目的がある。1つ目はHaskellの中で外部言語の機能に対するインターフェイスを提供することで、2つ目はHaskellが行う仕事を外部コードから利用することである。より一般的には、Haskellとほかの言語が混合したプログラムの実装をサポートし、それによってソースコードがHaskellの他の実装とHaskell以外のシステムにわたって移植性可能になり、さらにアーキテクチャとOSからも独立となる。

### 外部言語

HaskellのFFIは現在のところHaskellコードとC言語の呼び出し規約の従った外部コードの間のやりとりのみを対象としている。しかし、FFIのデザインはC++やJavaといったほかのプログラミング言語の呼び出し規約も含められるように現在の定義を組み合わせられる形で拡張することを可能にするようなものである。他の言語へのサポートの正確な定義はこの言語の今後のバージョンに含まれることが期待される。次に大きく省略されたのは外部言語のマルチスレッドとのやりとり、特にスレッドローカルな状態の扱いであり、そしてそれらの詳細は現時点では実装依存である。

現在の仕様のコアはHaskellと接続するのに使われる外部言語とは独立である。しかし、FFIの仕様が言語依存でなければならないところが2箇所ある: (1)外部の名前の仕様と(2)外部言語の基本型のマーシャリングである。前者の例としては、C言語においては単純な識別子でオブジェクトを識別するのに十分[9]であるのに対し、Javaでは一般に、引数に併せて修飾子付きの名前と、起こりうるオーバーローディングを解決するために結果の型が必要である[5]。2つ目のポイントに関しては、一部の基本型に対してその完全な表現を指定しない多くの言語を考えてみよ。例えばC言語の型`int`は16または32または64bitの長さをもつ。同様に、Haskellは`Int`が少なくとも`[-2^29,2^29-1]`(セクション6.4を見よ)の範囲をカバーすることしか保証しない。その結果としてC言語の`int`型の値をHaskellで信頼できる形で表現するためには、`int`の表現に適合することが保証されている新しい型`CInt`を導入するしかない。

呼び出し規約に依存する、外部の名前の仕様はセクション8.5で説明される。また、外部言語に依存する基本型のマーシャリングはセクション8.6で説明される。

### コンテキスト

Haskellのシステムが与えられたとき、**Haskellのコンテキスト**とは、Haskellシステムを支える抽象マシンの実行コンテキストのことと定義する。これはヒープ、スタック、そして抽象マシンのレジスタとそれらの具体的なアーキテクチャへの対応付けを含む。それ以外の任意の実行コンテキストを**外部コンテキスト**と呼ぶ。一般に、Haskellが明示的に規定した特別なデータフォーマットを除いては、Haskellコンテキストと与えられている外部コンテキストの間でデータフォーマット及び呼び出し規約のどんな互換性も仮定しない。

外部関数インターフェイスの主な目標はHaskellのコンテキストと外部コンテキストの間のプログラム可能なインターフェイスを提供することである。結果としてHaskellスレッドは外部コンテキストのデータにアクセスし、外部コンテキストで実行された関数を呼び出すことができ、さらにその逆もできる。本定義の残りの部分から、外部コンテキストは通常呼び出し規約によって識別される。

#### 言語を跨いだ型の一貫性

静的型をサポートした多くの外部言語が与えられているとき、Haskellの型と外部言語の型の一貫性を外部関数に対しても強制できるかどうかという疑問が出てくる。残念なことに、これは一般に、Haskellシステムの実装の側に大変に特別な仕組みをあらかじめ用意しておかなければ不可能である(すなわち、専用の型チェッカーを実装するなどをしない場合)。例えば、Cの呼び出し規約の場合では、Haskellの型からCのプロトタイプ宣言を生成し、インポートされた関数に対してCコンパイラにCのヘッダーファイルで指定されたプロトタイプと合致させることをCコンパイラに任せるのが唯一の他の方法である。しかしHaskellの型にはこの方法を追及するために必要とされる情報が揃っていない。特に、Haskellの型はいつ`const`修飾子が付けられるべきかについての情報を含んでいない。

結果として、この定義はHaskellシステムで外部型との一貫性をチェックすることを必要としない。しかしながら、Haskellシステムはほどよい努力で実装可能な言語を跨いだ一貫性チェックを提供することが推奨されている。

### 字句構造

FFIは`foreign`なる単一のキーワードと特別な識別子の集合を予約する。後者はforeign宣言の中でのみ特別な意味を持つが、他の場所では一般的な識別子としても使われることがある。

特別な識別子は`ccall, cplusplus, dotnet, jvm, stdcall`が呼び出し規約を表現するために定義されている。しかし個々のFFIの実装がここに挙げられていないシステム独自の呼び出し規約を追加で実装することに関しては自由である。

外部Cコンテキストのオブジェクトを参照するために、次の語句を導入する:

```haskell
chname	→	{chchar} . h    	    (C header filename)
cid	→	letter {letter | ascDigit}  (C identifier)
chchar	→	letter | ascSymbol⟨&⟩
letter	→	ascSmall | ascLarge | _
```

`chname`が認められているトークンの範囲は、Cの`#include`ディレクティブの引数として許されているもののサブセットである。特に、`chname`を名前に持つファイルは`.h`の接尾辞を付けなければならない。`cid`によって生成されたトークンは[9]で指定されているような、Cの識別子として許されているもの全体と一致する。。

### foreign宣言

foreign宣言の文法は次のようになる:

```haskell
topdecl	    →	'foreign' fdecl
fdecl	    →	'import' callconv [safety] impent var '::' ftype   (define variable)
            |	'export' callconv expent var '::' ftype	           (expose variable)
callconv    →	'ccall' | 'stdcall' | 'cplusplus'                  (calling convention)
            |	'jvm' | 'dotnet'
            |	system-specific calling conventions
impent	    →	[string]
expent	    →	[string]
safety	    →	'unsafe' | 'safe'
```

foreign宣言には2つの種類がある: import宣言とexport宣言である。import宣言は**外部エンティティ**すなわち外部コンテキストで定義され、Haskellコンテキストで利用可能な関数やメモリ番地を作成する。逆に、export宣言はHaskellコンテキストの関数を外部コンテキストの外部エンティティとして定義する。結論として、これらの宣言の2つの種類はimport宣言が新しい変数を定義するのに対し、export宣言はHaskellのモジュールですでに定義されている変数を用いるという点で異なる。

外部エンティティを含む外部コンテキストはforeign宣言で与えられた呼び出し規約によって決定される。結果として、外部エンティティの仕様の完全な形は呼び出し規約とそれがimport宣言に(impentとして)出現するか、export宣言に(expentとして)出現するかの両方に依存する。異なる呼び出し規約がある状態でも文法の一様性を提供するため、外部エンティティの説明がHaskellの文字列語句として出現することが保証されている。唯一の例外はこの文字列が空文字列であるとき(すなわち`""`の形をしているとき)で、この場合は文字列は全体で省略されることもある。

#### 呼び出し規約

与えられたアーキテクチャにおける外部エンティティへのバイナリーインターフェイスは呼び出し規約によって決定される。これはしばしば外部エンティティが実装したプログラミング言語にも依存するが、外部エンティティがコンパイルされたシステムにより強く依存するのが普通である。

呼び出し規約がプログラミング言語よりもシステムに支配されることの例としては、Java仮想マシン(JVM)[11]のバイトコードへコンパイルされたエンティティが、実装を書いたソース言語(エンティティはOberonによって実装されている)の規則ではなくJVMの規則に従う必要があるということがある。

HaskellのFFIの実装は最低でも`ccall`を用いて表示されたC言語の呼び出し規約を実装しなければならない。それ以外の呼び出し規約は任意である。一般に、呼び出し規約の集合はオープンである、すなわち、実装によっては追加で呼び出し規約をサポートすることを選んでいるものもある。`ccall`に加えて、表8.1に代表的な呼び出し規約の識別子を並べてある。

|識別子|それが表現する呼び出し規約|
|--|--|
|`ccall`|システムの標準的なCコンパイラの呼び出し規約|
|`cplusplus`|システムの標準的なC++コンパイラの呼び出し規約|
|`dotnet`|.NETプラットフォームの呼び出し規約|
|`jvm`|Java仮想マシンの呼び出し規約|
|`stdcall`|(Pascal規約に適合した)Win32 APIの呼び出し規約|
表8.1 呼び出し規約

実装はこれらの規約をすべて実装する必要はないが、これらのうちいずれかを実装するのであれば上に列挙された名前を使わなければならない。他の呼び出し規約に対しては、実装は適した名前を選ぶ自由がある。

ここでは`ccall`と`stdcall`の呼び出し規約の意味だけが定義される。より多くの呼び出し規約はHaskellの将来的なバージョンで追加されるかもしれない。

特定の呼び出し規約を実装するためには、Haskellシステムによって生成されたコードがシステムのターゲットコードによって大きく変動する可能性があることに注意しよう。例えば、呼び出し規約`jvm`は明らかに、Javaネイティブインターフェイス(JNI)[10]をターゲットとするようなJavaコードを生成するHaskellコンパイラのために実装されるが、Cコードを生成するHaskellコンパイラのために実装される。

#### 外部型

**基本外部型**の集合は次のような型によって構成される:

- `Char`, `Int`, `Double`, `Float`, `Bool`はHaskellの`Prelude`によってエクスポートされるものと同じである
- `Int8`, `Int16`, `Int32`, `Int64`, `Word8`, `Word16`, `Word32`, `Word64`, 任意の型`a`に対しての`Ptr a`, `FunPtr a`, `StablePtr a`は`Foreign` (セクション 24)によってエクスポートされているものである

FFIを実装するHaskellシステムは関数の引数及び戻り値としてHaskellと外部コンテキストの間でこれらの型がやり取りできるようにするべきである。

外部型は次のような文法によって生成される:

```haskell

ftype	→   frtype
        |   fatype  →  ftype
frtype	→   fatype
        |   ()
fatype	→   qtycon atype1 … atypek	    (k ≥ 0)
```

外部型は外部エンティティのHaskellにおける型である。Haskellの型のサブセットのみが外部型として許されており、型を制限したある集合のみが標準的な仕方でHaskellコンテキストと外部コンテキストの間で転送することができる。外部型は`at1 -> ⋅⋅⋅ -> atn -> rt` (`n ≥ 0`)の形をしている。これは外部エンティティの引数が`n`であることを表している。

外部関数はすべての引数に対して正格である。


